{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 ScreamingLib is a multiplatform library for creating Minecraft plugins/extensions. Module list \u00b6 Modules for servers \u00b6 Core (server) Tasker Event Hologram Healthindicator Lang NPC Packets Placeholders Command Scoreboards and sidebars Clickable signs Modules for proxy \u00b6 Core (proxy) Tasker Event Lang Command Compiling \u00b6 Requirements \u00b6 JDK 11 and higher Internet connection Clone the repo and run ./gradlew screamCompile . Binaries for each module will be present in the build/libs folder of each subproject and also in your local maven repository.","title":"Home"},{"location":"#home","text":"ScreamingLib is a multiplatform library for creating Minecraft plugins/extensions.","title":"Home"},{"location":"#module-list","text":"","title":"Module list"},{"location":"#modules-for-servers","text":"Core (server) Tasker Event Hologram Healthindicator Lang NPC Packets Placeholders Command Scoreboards and sidebars Clickable signs","title":"Modules for servers"},{"location":"#modules-for-proxy","text":"Core (proxy) Tasker Event Lang Command","title":"Modules for proxy"},{"location":"#compiling","text":"","title":"Compiling"},{"location":"#requirements","text":"JDK 11 and higher Internet connection Clone the repo and run ./gradlew screamCompile . Binaries for each module will be present in the build/libs folder of each subproject and also in your local maven repository.","title":"Requirements"},{"location":"nmsmapper/","text":"NMSMapper \u00b6 A Gradle plugin for generating multi-version NMS accessors. Mappings generated by this library can be browsed here . Disclaimer These mappings are provided \"AS-IS\" with no warranty, so mistakes are possible. We are only solving issues in classes, that we are actively using in ScreamingSandals plugins. If you want to fix anything, feel free to open a pull request or contact us on our Discord server. NMSMapper is made for servers! Many client-side mappings are missing. Warning Usage of this Gradle plugin requires significant knowledge of Java's Reflection ! Usage \u00b6 Compatibility This project requires Gradle >= 7.0. Maven is not supported. At least JDK 11 is needed for compiling, however the compiled classes use only Java 8 methods. 1 2 3 4 5 6 7 8 9 10 11 12 buildscript { repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { classpath 'org.screamingsandals.nms:NMSMapper:1.0.6' } } apply plugin: 'org.screamingsandals.nms' Examples \u00b6 Basic setup \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* First add a new source set. Don't use your main source set for generated stuff. */ sourceSets . main . java . srcDirs = [ 'src/generated/java' , 'src/main/java' ] /* All other things will be set inside the nmsGen method. */ nmsGen { basePackage = \"com.example.nms.accessors\" // All generated classes will be in this package. sourceSet = \"src/generated/java\" // All generated classes will be part of this source set. /* * This means that the folder will be cleared before generation. * * If this value is false, old no longer used classes won't be removed. */ cleanOnRebuild = true } Defining objects for generation \u00b6 We want to access the net.minecraft.core.Rotations class in our plugin. The following method generates a new class, named RotationsAccessor , which you can use to retrieve the type. 1 2 3 4 5 nmsGen { /* Setup, see chapter before */ reqClass ( 'net.minecraft.core.Rotations' ) } The generated code looks like this: 1 2 3 4 5 6 7 8 9 10 public class RotationsAccessor { public static Class <?> getType () { return AccessorUtils . getType ( RotationsAccessor . class , mapper -> { mapper . map ( \"spigot\" , \"1.9.4\" , \"net.minecraft.server.${V}.Vector3f\" ); mapper . map ( \"spigot\" , \"1.17\" , \"net.minecraft.core.Vector3f\" ); mapper . map ( \"mcp\" , \"1.9.4\" , \"net.minecraft.util.math.Rotations\" ); mapper . map ( \"mcp\" , \"1.17\" , \"net.minecraft.src.C_4709_\" ); }); } } We can see that we got a new static method, named getType() , which returns a class based on the version and platform (Spigot and Forge is supported). Okay, we have a class. But classes are not all, we also need to access some fields, methods or even constructors. 1 2 3 4 5 6 7 8 9 10 11 12 nmsGen { /* Setup, see chapter before */ reqClass ( 'net.minecraft.core.Rotations' ) . reqConstructor ( float , float , float ) . reqField ( 'x' ) . reqField ( 'y' ) . reqField ( 'z' ) . reqMethod ( 'getX' ) . reqMethod ( 'getY' ) . reqMethod ( 'getZ' ) } This will generate access methods for one constructor, three fields and three methods. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class RotationsAccessor { public static Class <?> getType () { } public static Field getFieldX () { } public static Field getFieldY () { } public static Field getFieldZ () { } public static Constructor <?> getConstructor0 () { } public static Method getMethodGetX1 () { } public static Method getMethodGetY1 () { } public static Method getMethodGetZ1 () { } } A generated access method for a field will always be called getField<Name> and will always return Field . A generated access method for a constructor will always be called getConstructor<Index> and will always return Constructor<?> . This index is generated from the specified order in build.gradle . A generated access method for a method will always be called getMethod<Name><Index> and will always return Method . Here the index is present, because multiple methods can have other parameters, but the same name. Info If a class, a field, a method or a constructor is not found, null is returned. Maybe you are asking: How to define parameters to methods? It's actually pretty easy, and the same applies to constructors: 1 2 3 4 5 6 7 8 9 nmsGen { /* Setup, see chapter before */ var Level = reqClass ( 'net.minecraft.world.level.Level' ) reqClass ( 'net.minecraft.world.entity.decoration.ArmorStand' ) . reqConstructor ( Level , double , double , double ) . reqMethod ( 'setSmall' , boolean ) } Parameters can be classes (e.g. String.class , in groovy you don't have to specify the .class suffix), strings ( java.lang.String ) or an another requested class (in this example it's Level). You can also specify an another NMS class as a parameter without requesting it, in this case you will have to add a prefix: & 1 2 3 4 5 6 7 nmsGen { /* Setup, see chapter before */ reqClass ( 'net.minecraft.world.entity.decoration.ArmorStand' ) . reqConstructor ( '&net.minecraft.world.level.Level' , double , double , double ) . reqMethod ( 'setSmall' , boolean ) } However, the accessor for Level will be generated anyways. If the class is an enum and we want to retrieve its enum value, we can simply use the reqEnumField method. 1 2 3 4 5 6 nmsGen { /* Setup, see chapter before */ reqClass ( 'net.minecraft.network.protocol.game.ServerboundClientCommandPacket$Action' ) . reqEnumField ( 'PERFORM_RESPAWN' ) } In this case, the getField method will be generated again, however it will return directly the Object instead of Field . 1 2 public static Object getFieldPERFORM_RESPAWN () { } * For generating accessor classes, you will have to execute the generateNmsComponents task. Using alternative mappings/custom versions \u00b6 If you want to use alternative mappings or specific versions for generating accessors, prefix the build.gradle declaration with <mappingtype>: and suffix it with :<version> . Available mapping types are mojang, searge, spigot, obfuscated . Mojang mappings are used by default (if available). Generating configurations for new versions \u00b6 Compatibility Versions lower than 1.9.4 are not supported and will not work! 1 $ ./gradlew generateNmsConfig -PminecraftVersion = <version>","title":"NMSMapper"},{"location":"nmsmapper/#nmsmapper","text":"A Gradle plugin for generating multi-version NMS accessors. Mappings generated by this library can be browsed here . Disclaimer These mappings are provided \"AS-IS\" with no warranty, so mistakes are possible. We are only solving issues in classes, that we are actively using in ScreamingSandals plugins. If you want to fix anything, feel free to open a pull request or contact us on our Discord server. NMSMapper is made for servers! Many client-side mappings are missing. Warning Usage of this Gradle plugin requires significant knowledge of Java's Reflection !","title":"NMSMapper"},{"location":"nmsmapper/#usage","text":"Compatibility This project requires Gradle >= 7.0. Maven is not supported. At least JDK 11 is needed for compiling, however the compiled classes use only Java 8 methods. 1 2 3 4 5 6 7 8 9 10 11 12 buildscript { repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { classpath 'org.screamingsandals.nms:NMSMapper:1.0.6' } } apply plugin: 'org.screamingsandals.nms'","title":"Usage"},{"location":"nmsmapper/#examples","text":"","title":"Examples"},{"location":"nmsmapper/#basic-setup","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* First add a new source set. Don't use your main source set for generated stuff. */ sourceSets . main . java . srcDirs = [ 'src/generated/java' , 'src/main/java' ] /* All other things will be set inside the nmsGen method. */ nmsGen { basePackage = \"com.example.nms.accessors\" // All generated classes will be in this package. sourceSet = \"src/generated/java\" // All generated classes will be part of this source set. /* * This means that the folder will be cleared before generation. * * If this value is false, old no longer used classes won't be removed. */ cleanOnRebuild = true }","title":"Basic setup"},{"location":"nmsmapper/#defining-objects-for-generation","text":"We want to access the net.minecraft.core.Rotations class in our plugin. The following method generates a new class, named RotationsAccessor , which you can use to retrieve the type. 1 2 3 4 5 nmsGen { /* Setup, see chapter before */ reqClass ( 'net.minecraft.core.Rotations' ) } The generated code looks like this: 1 2 3 4 5 6 7 8 9 10 public class RotationsAccessor { public static Class <?> getType () { return AccessorUtils . getType ( RotationsAccessor . class , mapper -> { mapper . map ( \"spigot\" , \"1.9.4\" , \"net.minecraft.server.${V}.Vector3f\" ); mapper . map ( \"spigot\" , \"1.17\" , \"net.minecraft.core.Vector3f\" ); mapper . map ( \"mcp\" , \"1.9.4\" , \"net.minecraft.util.math.Rotations\" ); mapper . map ( \"mcp\" , \"1.17\" , \"net.minecraft.src.C_4709_\" ); }); } } We can see that we got a new static method, named getType() , which returns a class based on the version and platform (Spigot and Forge is supported). Okay, we have a class. But classes are not all, we also need to access some fields, methods or even constructors. 1 2 3 4 5 6 7 8 9 10 11 12 nmsGen { /* Setup, see chapter before */ reqClass ( 'net.minecraft.core.Rotations' ) . reqConstructor ( float , float , float ) . reqField ( 'x' ) . reqField ( 'y' ) . reqField ( 'z' ) . reqMethod ( 'getX' ) . reqMethod ( 'getY' ) . reqMethod ( 'getZ' ) } This will generate access methods for one constructor, three fields and three methods. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class RotationsAccessor { public static Class <?> getType () { } public static Field getFieldX () { } public static Field getFieldY () { } public static Field getFieldZ () { } public static Constructor <?> getConstructor0 () { } public static Method getMethodGetX1 () { } public static Method getMethodGetY1 () { } public static Method getMethodGetZ1 () { } } A generated access method for a field will always be called getField<Name> and will always return Field . A generated access method for a constructor will always be called getConstructor<Index> and will always return Constructor<?> . This index is generated from the specified order in build.gradle . A generated access method for a method will always be called getMethod<Name><Index> and will always return Method . Here the index is present, because multiple methods can have other parameters, but the same name. Info If a class, a field, a method or a constructor is not found, null is returned. Maybe you are asking: How to define parameters to methods? It's actually pretty easy, and the same applies to constructors: 1 2 3 4 5 6 7 8 9 nmsGen { /* Setup, see chapter before */ var Level = reqClass ( 'net.minecraft.world.level.Level' ) reqClass ( 'net.minecraft.world.entity.decoration.ArmorStand' ) . reqConstructor ( Level , double , double , double ) . reqMethod ( 'setSmall' , boolean ) } Parameters can be classes (e.g. String.class , in groovy you don't have to specify the .class suffix), strings ( java.lang.String ) or an another requested class (in this example it's Level). You can also specify an another NMS class as a parameter without requesting it, in this case you will have to add a prefix: & 1 2 3 4 5 6 7 nmsGen { /* Setup, see chapter before */ reqClass ( 'net.minecraft.world.entity.decoration.ArmorStand' ) . reqConstructor ( '&net.minecraft.world.level.Level' , double , double , double ) . reqMethod ( 'setSmall' , boolean ) } However, the accessor for Level will be generated anyways. If the class is an enum and we want to retrieve its enum value, we can simply use the reqEnumField method. 1 2 3 4 5 6 nmsGen { /* Setup, see chapter before */ reqClass ( 'net.minecraft.network.protocol.game.ServerboundClientCommandPacket$Action' ) . reqEnumField ( 'PERFORM_RESPAWN' ) } In this case, the getField method will be generated again, however it will return directly the Object instead of Field . 1 2 public static Object getFieldPERFORM_RESPAWN () { } * For generating accessor classes, you will have to execute the generateNmsComponents task.","title":"Defining objects for generation"},{"location":"nmsmapper/#using-alternative-mappingscustom-versions","text":"If you want to use alternative mappings or specific versions for generating accessors, prefix the build.gradle declaration with <mappingtype>: and suffix it with :<version> . Available mapping types are mojang, searge, spigot, obfuscated . Mojang mappings are used by default (if available).","title":"Using alternative mappings/custom versions"},{"location":"nmsmapper/#generating-configurations-for-new-versions","text":"Compatibility Versions lower than 1.9.4 are not supported and will not work! 1 $ ./gradlew generateNmsConfig -PminecraftVersion = <version>","title":"Generating configurations for new versions"},{"location":"modules/command/","text":"Command \u00b6 Module required for creating multi-platform commands. Features \u00b6 Cloud Command Framework integration Usage \u00b6 Supported platforms are: bukkit, bungee, minestom, sponge, velocity Maven \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> command-YOUR_PLATFORM </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> provided </scope> </dependency> <!-- Optional, but recommended (change version to the latest if necessary) --> <!-- https://mvnrepository.com/artifact/cloud.commandframework/cloud-minecraft-extras --> <dependency> <groupId> cloud.commandframework </groupId> <artifactId> cloud-minecraft-extras </artifactId> <version> 1.5.0 </version> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package --> Gradle \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:command-YOUR_PLATFORM:2.0.1-SNAPSHOT' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:2.0.1-SNAPSHOT' // Optional, but recommended (change the version to the latest if necessary) // https://mvnrepository.com/artifact/cloud.commandframework/cloud-minecraft-extras implementation 'cloud.commandframework:cloud-minecraft-extras:1.5.0' } Examples \u00b6 Creating commands with Cloud \u00b6 Command service \u00b6 Let's start with creating a service that will construct all of our commands (feel free to copy paste the snippet). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Service ( dependsOn = { CloudConstructor . class }) public final class CommandService { @Provider ( level = Provider . Level . POST_ENABLE ) public static CommandManager < CommandSenderWrapper > provideCommandManager () { try { final CommandManager < CommandSenderWrapper > manager = CloudConstructor . construct ( CommandExecutionCoordinator . simpleCoordinator ()); // provides a central place for handling common command usage errors // remove this part if you don't have the cloud-minecraft-extras module new MinecraftExceptionHandler < CommandSenderWrapper > () . withDefaultHandlers () . withHandler ( MinecraftExceptionHandler . ExceptionType . NO_PERMISSION , ( senderWrapper , e ) -> // Component from Adventure Component . text ( \"Insufficient permissions!\" ) ) . withHandler ( MinecraftExceptionHandler . ExceptionType . INVALID_SYNTAX , ( senderWrapper , e ) -> // Component from Adventure Component . text ( \"Invalid syntax!\" ) ) . apply ( manager , s -> s ); return manager ; } catch ( Exception e ) { e . printStackTrace (); } return null ; } } Base command class \u00b6 Then, create an abstract class that will be extended by the command classes (feel free to copy paste the snippet). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @ServiceDependencies ( dependsOn = { CommandService . class // the command service class you created in the last step }) public abstract class BaseCommand { protected final @NonNull String name ; protected final @Nullable Permission permission ; protected final boolean allowConsole ; public BaseCommand ( String name , Permission permission , boolean allowConsole ) { this . name = name ; this . permission = permission ; this . allowConsole = allowConsole ; } public @NonNull String getName () { return name ; } public @Nullable Permission getPermission () { return permission ; } public boolean isConsoleAllowed () { return allowConsole ; } protected abstract void construct ( Command . Builder < CommandSenderWrapper > commandSenderWrapperBuilder , CommandManager < CommandSenderWrapper > manager ); @OnPostEnable public void construct ( @ProvidedBy ( CommandService . class ) CommandManager < CommandSenderWrapper > manager ) { // all commands will have the same root, e.g. /someplugin <command name> Command . Builder < CommandSenderWrapper > builder = manager . commandBuilder ( \"someplugin\" ) . literal ( name ); // or you can have separated commands // Command.Builder<CommandSenderWrapper> builder = manager.commandBuilder(name); // checks for permissions if ( permission != null ) { builder = builder . permission ( PredicatePermission . of ( SimpleCloudKey . of ( name ), perm -> perm . getType () == CommandSenderWrapper . Type . CONSOLE || permission . hasPermission ( perm ) ) ); } // sender will be directly PlayerWrapper, if console is not allowed if ( ! allowConsole ) { builder = builder . senderType ( PlayerWrapper . class ); } construct ( builder , manager ); } } Command implementation \u00b6 Now let's actually implement the command. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Service public class ExampleCommand extends BaseCommand { // extend the base command class that we created in the last step public ExampleCommand () { // command name, command permission (can be null for no permission), is console allowed? super ( \"examplecommand\" , null , true ); } @Override protected void construct ( Command . Builder < CommandSenderWrapper > commandSenderWrapperBuilder , CommandManager < CommandSenderWrapper > manager ) { manager . command ( commandSenderWrapperBuilder // PlayerWrapper argument . argument ( manager . argumentBuilder ( String . class , \"player\" ) . withSuggestionsProvider (( c , s ) -> Server . getConnectedPlayers (). stream (). map ( PlayerWrapper :: getName ). toList () ) ) . handler ( commandContext -> { final Optional < PlayerWrapper > player = PlayerMapper . getPlayer (( String ) commandContext . get ( \"player\" )); if ( player . isEmpty ()) { commandContext . getSender (). sendMessage ( \"Invalid player specified!\" ); return ; } final String senderName = ( commandContext . getSender (). getType () == CommandSenderWrapper . Type . CONSOLE ) ? \"CONSOLE\" : commandContext . getSender (). as ( PlayerWrapper . class ). getName (); player . orElseThrow (). sendMessage ( \"Hello from \" + senderName ); }) ); } } Now register the command implementation class in your plugin's @Init annotation, and you're done! You've just made yourself a command in the /someplugin examplecommand <player> format.","title":"Command"},{"location":"modules/command/#command","text":"Module required for creating multi-platform commands.","title":"Command"},{"location":"modules/command/#features","text":"Cloud Command Framework integration","title":"Features"},{"location":"modules/command/#usage","text":"Supported platforms are: bukkit, bungee, minestom, sponge, velocity","title":"Usage"},{"location":"modules/command/#maven","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> command-YOUR_PLATFORM </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> provided </scope> </dependency> <!-- Optional, but recommended (change version to the latest if necessary) --> <!-- https://mvnrepository.com/artifact/cloud.commandframework/cloud-minecraft-extras --> <dependency> <groupId> cloud.commandframework </groupId> <artifactId> cloud-minecraft-extras </artifactId> <version> 1.5.0 </version> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package -->","title":"Maven"},{"location":"modules/command/#gradle","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:command-YOUR_PLATFORM:2.0.1-SNAPSHOT' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:2.0.1-SNAPSHOT' // Optional, but recommended (change the version to the latest if necessary) // https://mvnrepository.com/artifact/cloud.commandframework/cloud-minecraft-extras implementation 'cloud.commandframework:cloud-minecraft-extras:1.5.0' }","title":"Gradle"},{"location":"modules/command/#examples","text":"","title":"Examples"},{"location":"modules/command/#creating-commands-with-cloud","text":"","title":"Creating commands with Cloud"},{"location":"modules/command/#command-service","text":"Let's start with creating a service that will construct all of our commands (feel free to copy paste the snippet). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Service ( dependsOn = { CloudConstructor . class }) public final class CommandService { @Provider ( level = Provider . Level . POST_ENABLE ) public static CommandManager < CommandSenderWrapper > provideCommandManager () { try { final CommandManager < CommandSenderWrapper > manager = CloudConstructor . construct ( CommandExecutionCoordinator . simpleCoordinator ()); // provides a central place for handling common command usage errors // remove this part if you don't have the cloud-minecraft-extras module new MinecraftExceptionHandler < CommandSenderWrapper > () . withDefaultHandlers () . withHandler ( MinecraftExceptionHandler . ExceptionType . NO_PERMISSION , ( senderWrapper , e ) -> // Component from Adventure Component . text ( \"Insufficient permissions!\" ) ) . withHandler ( MinecraftExceptionHandler . ExceptionType . INVALID_SYNTAX , ( senderWrapper , e ) -> // Component from Adventure Component . text ( \"Invalid syntax!\" ) ) . apply ( manager , s -> s ); return manager ; } catch ( Exception e ) { e . printStackTrace (); } return null ; } }","title":"Command service"},{"location":"modules/command/#base-command-class","text":"Then, create an abstract class that will be extended by the command classes (feel free to copy paste the snippet). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @ServiceDependencies ( dependsOn = { CommandService . class // the command service class you created in the last step }) public abstract class BaseCommand { protected final @NonNull String name ; protected final @Nullable Permission permission ; protected final boolean allowConsole ; public BaseCommand ( String name , Permission permission , boolean allowConsole ) { this . name = name ; this . permission = permission ; this . allowConsole = allowConsole ; } public @NonNull String getName () { return name ; } public @Nullable Permission getPermission () { return permission ; } public boolean isConsoleAllowed () { return allowConsole ; } protected abstract void construct ( Command . Builder < CommandSenderWrapper > commandSenderWrapperBuilder , CommandManager < CommandSenderWrapper > manager ); @OnPostEnable public void construct ( @ProvidedBy ( CommandService . class ) CommandManager < CommandSenderWrapper > manager ) { // all commands will have the same root, e.g. /someplugin <command name> Command . Builder < CommandSenderWrapper > builder = manager . commandBuilder ( \"someplugin\" ) . literal ( name ); // or you can have separated commands // Command.Builder<CommandSenderWrapper> builder = manager.commandBuilder(name); // checks for permissions if ( permission != null ) { builder = builder . permission ( PredicatePermission . of ( SimpleCloudKey . of ( name ), perm -> perm . getType () == CommandSenderWrapper . Type . CONSOLE || permission . hasPermission ( perm ) ) ); } // sender will be directly PlayerWrapper, if console is not allowed if ( ! allowConsole ) { builder = builder . senderType ( PlayerWrapper . class ); } construct ( builder , manager ); } }","title":"Base command class"},{"location":"modules/command/#command-implementation","text":"Now let's actually implement the command. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Service public class ExampleCommand extends BaseCommand { // extend the base command class that we created in the last step public ExampleCommand () { // command name, command permission (can be null for no permission), is console allowed? super ( \"examplecommand\" , null , true ); } @Override protected void construct ( Command . Builder < CommandSenderWrapper > commandSenderWrapperBuilder , CommandManager < CommandSenderWrapper > manager ) { manager . command ( commandSenderWrapperBuilder // PlayerWrapper argument . argument ( manager . argumentBuilder ( String . class , \"player\" ) . withSuggestionsProvider (( c , s ) -> Server . getConnectedPlayers (). stream (). map ( PlayerWrapper :: getName ). toList () ) ) . handler ( commandContext -> { final Optional < PlayerWrapper > player = PlayerMapper . getPlayer (( String ) commandContext . get ( \"player\" )); if ( player . isEmpty ()) { commandContext . getSender (). sendMessage ( \"Invalid player specified!\" ); return ; } final String senderName = ( commandContext . getSender (). getType () == CommandSenderWrapper . Type . CONSOLE ) ? \"CONSOLE\" : commandContext . getSender (). as ( PlayerWrapper . class ). getName (); player . orElseThrow (). sendMessage ( \"Hello from \" + senderName ); }) ); } } Now register the command implementation class in your plugin's @Init annotation, and you're done! You've just made yourself a command in the /someplugin examplecommand <player> format.","title":"Command implementation"},{"location":"modules/core/","text":"Core (server) \u00b6 Base module required for pretty much everything in SLib. Contains the base features for working with the server, such as the item API, block API, entities API and more. All other modules require this module to be present. Platform support \u00b6 Minecraft: Java Edition <1.9.4 1.9.4 1.10.x 1.11.x 1.12.x 1.13.x 1.14.x 1.15.x 1.16.x 1.17.x Spigot / Paper (and forks) No Yes Yes Yes Yes Yes Yes Yes Yes Yes Glowstone No ? ? ? ? ? MohistMC (and similar) No ? ? ? Minestom No Planned Sponge API 8+ Planned Planned ? = the version may be supported, but the current state is unknown Empty field = there's no such version of the specific platform Support for the Bedrock Edition is also planned, but not anytime soon. Minecraft: Bedrock Edition Latest Nukkit Planned Cloudburst Planned Usage \u00b6 Supported platforms are: bukkit, minestom, sponge Maven \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> core-YOUR_PLATFORM </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package --> Gradle \u00b6 1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:core-YOUR_PLATFORM:2.0.1-SNAPSHOT' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:2.0.1-SNAPSHOT' } Comparison to the Bukkit API \u00b6 Bukkit API class SLib class Player PlayerWrapper HumanEntity EntityHuman LivingEntity EntityLiving Projectile EntityProjectile Item EntityItem ExperienceOrb EntityExperience LightningStrike EntityLightning Firework EntityFirework Entity EntityBasic World WorldHolder Location LocationHolder Block BlockHolder Material ItemTypeHolder (for item materials), BlockTypeHolder (for block materials) Server Server ItemStack Item Holders \u00b6 ScreamingLib makes use of so-called Holders, platform unopinionated data holding classes. Holders make use of Minecraft namespaced keys to stay platform independent. A very useful resource for getting Minecraft namespaced keys is Articdive's ArticData repository. Instantiating \u00b6 You can instantiate a holder with the <Anything>Holder#of(Object) method. BlockTypeHolder and ItemTypeHolder \u00b6 For example, I'm going to create a holder holding the stone material. 1 2 3 4 5 final BlockTypeHolder block = BlockTypeHolder . of ( \"minecraft:stone\" ); final ItemTypeHolder item = ItemTypeHolder . of ( \"minecraft:stone\" ); // both are going to be STONE on bukkit PlayerMapper . getConsoleSender (). sendMessage ( block . platformName ()); PlayerMapper . getConsoleSender (). sendMessage ( item . platformName ()); Comparing \u00b6 You can compare a holder with the <Anything>Holder#is(Object) method. BlockTypeHolder and ItemTypeHolder \u00b6 For example, I'm going to check if the material is stone, air or something else. 1 2 3 4 5 6 7 if ( holder . is ( \"minecraft:stone\" )) { PlayerMapper . getConsoleSender (). sendMessage ( \"Holder is stone!\" ); } else if ( holder . isAir ()) { PlayerMapper . getConsoleSender (). sendMessage ( \"Holder is air/empty!\" ); } else { PlayerMapper . getConsoleSender (). sendMessage ( \"Holder is \" + holder . platformName () + \"!\" ); } Services \u00b6 Services are classes with the @Service annotation, specified in the @Init annotation on the main plugin class. They are initialized when the plugin starts to load. It is possible to retrieve the service class instances with the ServiceManager class ( ServiceManager#get(Class<?>) ). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Service ( dependsOn = { SomeExampleServiceThatThisDependsOn . class }, loadAfter = { SomeExampleServiceThatWillBeLoadedBeforeThis . class }) public class ExampleService { @OnPostConstruct public void onConstruct () { // Service construction logic } @OnEnable public void enable () { // Service enable logic } @OnDisable public void disable () { // Service disable logic (plugin is disabling) } } Annotations \u00b6 @Service(dependsOn = {}, loadAfter = {}) - Marks the annotated class as a service. Service classes specified in the dependsOn field are loaded before initializing the annotated class, while service classes specified in the loadAfter field are loaded after initializing the annotated class. @OnPostConstruct - Marks the annotated method to run directly after the service class is constructed. @OnEnable - Marks the annotated method to run after the service class is initialized. @OnDisable - Marks the annotated method to run after the service class is being disabled (plugin is disabling). @Init(platforms = {}, services = {}) (plugin class only) - Defines service classes that should be initialized when the plugin is loading (order sensitive). In the platforms field, you can specify platforms that the service classes in the annotation will be initialized on (array of PlatformType , can be left out). Examples \u00b6 Iterating over online players \u00b6 If you want to iterate over all online players and compute something for each one, utilize the List<PlayerWrapper> Server#getConnectedPlayers() method. 1 2 3 4 5 6 // for loop for ( final PlayerWrapper player : Server . getConnectedPlayers ()) { player . sendMessage ( \"Hello!\" ); } // Iterable#forEach() Server . getConnectedPlayers (). forEach ( player -> player . sendMessage ( \"Hello!\" )); Retrieving a player \u00b6 Converting a platform player to PlayerWrapper \u00b6 If you want to convert a platform player (e.g. Bukkit's Player ) to PlayerWrapper , utilize the PlayerWrapper PlayerMapper#wrapPlayer(Object) method. 1 2 final PlayerWrapper player = PlayerMapper . wrapPlayer ( platformPlayer ); player . sendMessage ( \"Hello!\" ); Converting a UUID to OfflinePlayerWrapper \u00b6 If you want to convert a UUID to an OfflinePlayerWrapper, utilize the OfflinePlayerWrapper PlayerMapper#wrapOfflinePlayer(Object) method. 1 2 3 // will probably throw UnsupportedOperationException, since the random UUID doesn't belong to a player that has joined your server final OfflinePlayerWrapper player = PlayerMapper . wrapPlayer ( UUID . randomUUID ()); PlayerMapper . getConsoleSender (). sendMessage ( \"Is player online? \" + Boolean . toString ( player . isOnline ())); Converting a name to PlayerWrapper \u00b6 If you want to convert a player's name to PlayerWrapper, utilize the Optional<PlayerWrapper> PlayerMapper#getPlayer(String) method. 1 2 3 4 5 6 final Optional < PlayerWrapper > player = PlayerMapper . getPlayer ( \"Misat11\" ); if ( player . isPresent ()) { player . orElseThrow (). sendMessage ( \"Hello misat!\" ); } else { PlayerMapper . getConsoleSender (). sendMessage ( \"Misat is not online!\" ); }","title":"Core"},{"location":"modules/core/#core-server","text":"Base module required for pretty much everything in SLib. Contains the base features for working with the server, such as the item API, block API, entities API and more. All other modules require this module to be present.","title":"Core (server)"},{"location":"modules/core/#platform-support","text":"Minecraft: Java Edition <1.9.4 1.9.4 1.10.x 1.11.x 1.12.x 1.13.x 1.14.x 1.15.x 1.16.x 1.17.x Spigot / Paper (and forks) No Yes Yes Yes Yes Yes Yes Yes Yes Yes Glowstone No ? ? ? ? ? MohistMC (and similar) No ? ? ? Minestom No Planned Sponge API 8+ Planned Planned ? = the version may be supported, but the current state is unknown Empty field = there's no such version of the specific platform Support for the Bedrock Edition is also planned, but not anytime soon. Minecraft: Bedrock Edition Latest Nukkit Planned Cloudburst Planned","title":"Platform support"},{"location":"modules/core/#usage","text":"Supported platforms are: bukkit, minestom, sponge","title":"Usage"},{"location":"modules/core/#maven","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> core-YOUR_PLATFORM </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package -->","title":"Maven"},{"location":"modules/core/#gradle","text":"1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:core-YOUR_PLATFORM:2.0.1-SNAPSHOT' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:2.0.1-SNAPSHOT' }","title":"Gradle"},{"location":"modules/core/#comparison-to-the-bukkit-api","text":"Bukkit API class SLib class Player PlayerWrapper HumanEntity EntityHuman LivingEntity EntityLiving Projectile EntityProjectile Item EntityItem ExperienceOrb EntityExperience LightningStrike EntityLightning Firework EntityFirework Entity EntityBasic World WorldHolder Location LocationHolder Block BlockHolder Material ItemTypeHolder (for item materials), BlockTypeHolder (for block materials) Server Server ItemStack Item","title":"Comparison to the Bukkit API"},{"location":"modules/core/#holders","text":"ScreamingLib makes use of so-called Holders, platform unopinionated data holding classes. Holders make use of Minecraft namespaced keys to stay platform independent. A very useful resource for getting Minecraft namespaced keys is Articdive's ArticData repository.","title":"Holders"},{"location":"modules/core/#instantiating","text":"You can instantiate a holder with the <Anything>Holder#of(Object) method.","title":"Instantiating"},{"location":"modules/core/#blocktypeholder-and-itemtypeholder","text":"For example, I'm going to create a holder holding the stone material. 1 2 3 4 5 final BlockTypeHolder block = BlockTypeHolder . of ( \"minecraft:stone\" ); final ItemTypeHolder item = ItemTypeHolder . of ( \"minecraft:stone\" ); // both are going to be STONE on bukkit PlayerMapper . getConsoleSender (). sendMessage ( block . platformName ()); PlayerMapper . getConsoleSender (). sendMessage ( item . platformName ());","title":"BlockTypeHolder and ItemTypeHolder"},{"location":"modules/core/#comparing","text":"You can compare a holder with the <Anything>Holder#is(Object) method.","title":"Comparing"},{"location":"modules/core/#blocktypeholder-and-itemtypeholder_1","text":"For example, I'm going to check if the material is stone, air or something else. 1 2 3 4 5 6 7 if ( holder . is ( \"minecraft:stone\" )) { PlayerMapper . getConsoleSender (). sendMessage ( \"Holder is stone!\" ); } else if ( holder . isAir ()) { PlayerMapper . getConsoleSender (). sendMessage ( \"Holder is air/empty!\" ); } else { PlayerMapper . getConsoleSender (). sendMessage ( \"Holder is \" + holder . platformName () + \"!\" ); }","title":"BlockTypeHolder and ItemTypeHolder"},{"location":"modules/core/#services","text":"Services are classes with the @Service annotation, specified in the @Init annotation on the main plugin class. They are initialized when the plugin starts to load. It is possible to retrieve the service class instances with the ServiceManager class ( ServiceManager#get(Class<?>) ). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Service ( dependsOn = { SomeExampleServiceThatThisDependsOn . class }, loadAfter = { SomeExampleServiceThatWillBeLoadedBeforeThis . class }) public class ExampleService { @OnPostConstruct public void onConstruct () { // Service construction logic } @OnEnable public void enable () { // Service enable logic } @OnDisable public void disable () { // Service disable logic (plugin is disabling) } }","title":"Services"},{"location":"modules/core/#annotations","text":"@Service(dependsOn = {}, loadAfter = {}) - Marks the annotated class as a service. Service classes specified in the dependsOn field are loaded before initializing the annotated class, while service classes specified in the loadAfter field are loaded after initializing the annotated class. @OnPostConstruct - Marks the annotated method to run directly after the service class is constructed. @OnEnable - Marks the annotated method to run after the service class is initialized. @OnDisable - Marks the annotated method to run after the service class is being disabled (plugin is disabling). @Init(platforms = {}, services = {}) (plugin class only) - Defines service classes that should be initialized when the plugin is loading (order sensitive). In the platforms field, you can specify platforms that the service classes in the annotation will be initialized on (array of PlatformType , can be left out).","title":"Annotations"},{"location":"modules/core/#examples","text":"","title":"Examples"},{"location":"modules/core/#iterating-over-online-players","text":"If you want to iterate over all online players and compute something for each one, utilize the List<PlayerWrapper> Server#getConnectedPlayers() method. 1 2 3 4 5 6 // for loop for ( final PlayerWrapper player : Server . getConnectedPlayers ()) { player . sendMessage ( \"Hello!\" ); } // Iterable#forEach() Server . getConnectedPlayers (). forEach ( player -> player . sendMessage ( \"Hello!\" ));","title":"Iterating over online players"},{"location":"modules/core/#retrieving-a-player","text":"","title":"Retrieving a player"},{"location":"modules/core/#converting-a-platform-player-to-playerwrapper","text":"If you want to convert a platform player (e.g. Bukkit's Player ) to PlayerWrapper , utilize the PlayerWrapper PlayerMapper#wrapPlayer(Object) method. 1 2 final PlayerWrapper player = PlayerMapper . wrapPlayer ( platformPlayer ); player . sendMessage ( \"Hello!\" );","title":"Converting a platform player to PlayerWrapper"},{"location":"modules/core/#converting-a-uuid-to-offlineplayerwrapper","text":"If you want to convert a UUID to an OfflinePlayerWrapper, utilize the OfflinePlayerWrapper PlayerMapper#wrapOfflinePlayer(Object) method. 1 2 3 // will probably throw UnsupportedOperationException, since the random UUID doesn't belong to a player that has joined your server final OfflinePlayerWrapper player = PlayerMapper . wrapPlayer ( UUID . randomUUID ()); PlayerMapper . getConsoleSender (). sendMessage ( \"Is player online? \" + Boolean . toString ( player . isOnline ()));","title":"Converting a UUID to OfflinePlayerWrapper"},{"location":"modules/core/#converting-a-name-to-playerwrapper","text":"If you want to convert a player's name to PlayerWrapper, utilize the Optional<PlayerWrapper> PlayerMapper#getPlayer(String) method. 1 2 3 4 5 6 final Optional < PlayerWrapper > player = PlayerMapper . getPlayer ( \"Misat11\" ); if ( player . isPresent ()) { player . orElseThrow (). sendMessage ( \"Hello misat!\" ); } else { PlayerMapper . getConsoleSender (). sendMessage ( \"Misat is not online!\" ); }","title":"Converting a name to PlayerWrapper"},{"location":"modules/event/","text":"Event \u00b6 Module required for handling and dispatching events. Features \u00b6 Event priorities Ignoring cancellation Synchronous and asynchronous events Listening/firing events Usage \u00b6 Supported platforms are: bukkit, sponge, bungee, velocity Maven \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> event-YOUR_PLATFORM </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package --> Gradle \u00b6 1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:event-YOUR_PLATFORM:2.0.1-SNAPSHOT' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:2.0.1-SNAPSHOT' } Examples \u00b6 Handling events \u00b6 EventManager ScreamingLib EventManager is not listening to non-standard events fired through the event manager of the platform you're running on! OnEvent annotation \u00b6 First of all, start by making a simple service class, like this: 1 2 3 4 @Service public class ExampleService { // Service class } Then create a new public method that returns void, has an event parameter and annotate it with @OnEvent . It is possible to specify the priority field and the ignoreCancelled field in the annotation. 1 2 3 4 5 6 7 @Service public class ExampleService { @OnEvent ( priority = EventPriority . HIGHEST , ignoreCancelled = true ) public void onPlayerInteract ( SPlayerInteractEvent event ) { // Event handling logic } } Then register the service class in the @Init annotation on the main plugin class, and you're done! EventManager registration \u00b6 You can also listen to events by registering a Consumer<AbstractEvent> with the EventManager . 1 EventManager . getDefaultEventManager (). register ( SPlayerLeaveEvent . class , event -> PlayerMapper . getConsoleSender (). sendMessage ( \"Player \" + event . getPlayer () + \" has left.\" )); Firing events \u00b6 EventManager ScreamingLib EventManager is not firing events to the event manager of the platform you're running on! Synchronously \u00b6 You can fire an event synchronously with the <T extends AbstractEvent> T EventManager#fire(T) method. 1 2 3 4 5 final ExampleEvent event = EventManager . fire ( new ExampleEvent ()); // if your event is cancellable, you can check for it if ( ! event . isCancelled ()) { PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" ); } Asynchronously \u00b6 You can fire an event asynchronously with the <T extends AbstractEvent> CompletableFuture<T> EventManager#fireAsync(T) method. 1 2 3 4 5 6 EventManager . fireAsync ( new ExampleAsynchronousEvent ()). thenAccept ( event -> { // if your event is cancellable, you can check for it if ( ! event . isCancelled ()) { PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" ); } }); Creating events \u00b6 Synchronous \u00b6 A synchronous event needs to extend the AbstractEvent class (or the CancellableAbstractEvent class, if cancellable). 1 2 3 4 5 6 7 8 9 10 11 12 13 public class ExampleEvent extends CancellableAbstractEvent { private boolean cancelled = false ; @Override public void setCancelled ( boolean cancelled ) { this . cancelled = cancelled ; } @Override public boolean isCancelled () { return cancelled ; } } Asynchronous \u00b6 An asynchronous event needs to extend the AbstractAsyncEvent class (or the CancellableAbstractAsyncEvent , if cancellable). 1 2 3 4 5 6 7 8 9 10 11 12 13 public class ExampleEvent extends CancellableAbstractAsyncEvent { private boolean cancelled = false ; @Override public void setCancelled ( boolean cancelled ) { this . cancelled = cancelled ; } @Override public boolean isCancelled () { return cancelled ; } }","title":"Event"},{"location":"modules/event/#event","text":"Module required for handling and dispatching events.","title":"Event"},{"location":"modules/event/#features","text":"Event priorities Ignoring cancellation Synchronous and asynchronous events Listening/firing events","title":"Features"},{"location":"modules/event/#usage","text":"Supported platforms are: bukkit, sponge, bungee, velocity","title":"Usage"},{"location":"modules/event/#maven","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> event-YOUR_PLATFORM </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package -->","title":"Maven"},{"location":"modules/event/#gradle","text":"1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:event-YOUR_PLATFORM:2.0.1-SNAPSHOT' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:2.0.1-SNAPSHOT' }","title":"Gradle"},{"location":"modules/event/#examples","text":"","title":"Examples"},{"location":"modules/event/#handling-events","text":"EventManager ScreamingLib EventManager is not listening to non-standard events fired through the event manager of the platform you're running on!","title":"Handling events"},{"location":"modules/event/#onevent-annotation","text":"First of all, start by making a simple service class, like this: 1 2 3 4 @Service public class ExampleService { // Service class } Then create a new public method that returns void, has an event parameter and annotate it with @OnEvent . It is possible to specify the priority field and the ignoreCancelled field in the annotation. 1 2 3 4 5 6 7 @Service public class ExampleService { @OnEvent ( priority = EventPriority . HIGHEST , ignoreCancelled = true ) public void onPlayerInteract ( SPlayerInteractEvent event ) { // Event handling logic } } Then register the service class in the @Init annotation on the main plugin class, and you're done!","title":"OnEvent annotation"},{"location":"modules/event/#eventmanager-registration","text":"You can also listen to events by registering a Consumer<AbstractEvent> with the EventManager . 1 EventManager . getDefaultEventManager (). register ( SPlayerLeaveEvent . class , event -> PlayerMapper . getConsoleSender (). sendMessage ( \"Player \" + event . getPlayer () + \" has left.\" ));","title":"EventManager registration"},{"location":"modules/event/#firing-events","text":"EventManager ScreamingLib EventManager is not firing events to the event manager of the platform you're running on!","title":"Firing events"},{"location":"modules/event/#synchronously","text":"You can fire an event synchronously with the <T extends AbstractEvent> T EventManager#fire(T) method. 1 2 3 4 5 final ExampleEvent event = EventManager . fire ( new ExampleEvent ()); // if your event is cancellable, you can check for it if ( ! event . isCancelled ()) { PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" ); }","title":"Synchronously"},{"location":"modules/event/#asynchronously","text":"You can fire an event asynchronously with the <T extends AbstractEvent> CompletableFuture<T> EventManager#fireAsync(T) method. 1 2 3 4 5 6 EventManager . fireAsync ( new ExampleAsynchronousEvent ()). thenAccept ( event -> { // if your event is cancellable, you can check for it if ( ! event . isCancelled ()) { PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" ); } });","title":"Asynchronously"},{"location":"modules/event/#creating-events","text":"","title":"Creating events"},{"location":"modules/event/#synchronous","text":"A synchronous event needs to extend the AbstractEvent class (or the CancellableAbstractEvent class, if cancellable). 1 2 3 4 5 6 7 8 9 10 11 12 13 public class ExampleEvent extends CancellableAbstractEvent { private boolean cancelled = false ; @Override public void setCancelled ( boolean cancelled ) { this . cancelled = cancelled ; } @Override public boolean isCancelled () { return cancelled ; } }","title":"Synchronous"},{"location":"modules/event/#asynchronous","text":"An asynchronous event needs to extend the AbstractAsyncEvent class (or the CancellableAbstractAsyncEvent , if cancellable). 1 2 3 4 5 6 7 8 9 10 11 12 13 public class ExampleEvent extends CancellableAbstractAsyncEvent { private boolean cancelled = false ; @Override public void setCancelled ( boolean cancelled ) { this . cancelled = cancelled ; } @Override public boolean isCancelled () { return cancelled ; } }","title":"Asynchronous"},{"location":"modules/npc/","text":"NPC \u00b6 Module for creating multi-platform NPC entities. Features \u00b6 Multiline names Skins Head following player Usage \u00b6 Supported platforms are the same as the packets module, because this module doesn't have any platform specific code. Maven \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> npc-YOUR_PLATFORM </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package --> Gradle \u00b6 1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:npc-YOUR_PLATFORM:2.0.1-SNAPSHOT' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:2.0.1-SNAPSHOT' } Examples \u00b6 Creating your first NPC \u00b6 Start by spawning the NPC on a specified location, like this: 1 final NPC npc = NPC . of ( yourLocation ); Now let's set a nice skin for the NPC. I'll use Misat's skin in this example. 1 2 3 4 5 6 7 8 final PlayerWrapper misat = PlayerMapper . getPlayer ( \"Misat11\" ). orElseThrow (() -> new RuntimeException ( \"No misat here lol\" )); final NPC npc = NPC . of ( yourLocation ) NPCSkin . retrieveSkin ( misat . getUuid ()). thenAccept ( skin -> { // null if an error occurred, like no internet connection if ( skin != null ) { npc . setSkin ( skin ); } }) I think that NPC's looking into your soul are not creepy at all, so let's make the NPC look at players and let's give it a name. 1 2 3 4 5 final NPC npc = ...; // you can totally do this in the npc builder, i chose not to, because i didn't want to copy the huge block of skin values npc . setShouldLookAtPlayer ( true ); // requires a List<Component> to allow for multiline names npc . setDisplayName ( Arrays . asList ( Component . text ( \"Misat11\" ))); And you've made yourself a fresh new NPC! Destroying a NPC \u00b6 If you want to destroy a NPC, you can call the LocatableVisual#destroy() method. 1 2 final NPC npc = NPC . of ( yourLocation ); npc . destroy ();","title":"NPC"},{"location":"modules/npc/#npc","text":"Module for creating multi-platform NPC entities.","title":"NPC"},{"location":"modules/npc/#features","text":"Multiline names Skins Head following player","title":"Features"},{"location":"modules/npc/#usage","text":"Supported platforms are the same as the packets module, because this module doesn't have any platform specific code.","title":"Usage"},{"location":"modules/npc/#maven","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> npc-YOUR_PLATFORM </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package -->","title":"Maven"},{"location":"modules/npc/#gradle","text":"1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:npc-YOUR_PLATFORM:2.0.1-SNAPSHOT' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:2.0.1-SNAPSHOT' }","title":"Gradle"},{"location":"modules/npc/#examples","text":"","title":"Examples"},{"location":"modules/npc/#creating-your-first-npc","text":"Start by spawning the NPC on a specified location, like this: 1 final NPC npc = NPC . of ( yourLocation ); Now let's set a nice skin for the NPC. I'll use Misat's skin in this example. 1 2 3 4 5 6 7 8 final PlayerWrapper misat = PlayerMapper . getPlayer ( \"Misat11\" ). orElseThrow (() -> new RuntimeException ( \"No misat here lol\" )); final NPC npc = NPC . of ( yourLocation ) NPCSkin . retrieveSkin ( misat . getUuid ()). thenAccept ( skin -> { // null if an error occurred, like no internet connection if ( skin != null ) { npc . setSkin ( skin ); } }) I think that NPC's looking into your soul are not creepy at all, so let's make the NPC look at players and let's give it a name. 1 2 3 4 5 final NPC npc = ...; // you can totally do this in the npc builder, i chose not to, because i didn't want to copy the huge block of skin values npc . setShouldLookAtPlayer ( true ); // requires a List<Component> to allow for multiline names npc . setDisplayName ( Arrays . asList ( Component . text ( \"Misat11\" ))); And you've made yourself a fresh new NPC!","title":"Creating your first NPC"},{"location":"modules/npc/#destroying-a-npc","text":"If you want to destroy a NPC, you can call the LocatableVisual#destroy() method. 1 2 final NPC npc = NPC . of ( yourLocation ); npc . destroy ();","title":"Destroying a NPC"},{"location":"modules/packets/","text":"Packets \u00b6 Module for accessing Minecraft's packets. Features \u00b6 Sending packets Listening to packets Usage \u00b6 Supported platforms are: bukkit Packet availability Not all packets are currently mapped! Most serverbound packets are currently not available. Maven \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> packets-YOUR_PLATFORM </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package --> Gradle \u00b6 1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:packets-YOUR_PLATFORM:2.0.1-SNAPSHOT' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:2.0.1-SNAPSHOT' } Examples \u00b6 Sending a packet \u00b6 I will demonstrate the functionality on the ClientboundDisconnectPacket. First of all, construct the SLib packet with it's constructor. 1 final SClientboundDisconnectPacket packet = new SClientboundDisconnectPacket (); Then, add the data to the packet. 1 2 final SClientboundDisconnectPacket packet = new SClientboundDisconnectPacket (); packet . reason ( Component . text ( \"You were kicked, because why not.\" )); And lastly, send the packet. 1 2 3 final SClientboundDisconnectPacket packet = new SClientboundDisconnectPacket (); packet . reason ( Component . text ( \"You were kicked, because why not.\" )); packet . sendPacket ( player ); It is also possible to directly supply the data in the constructor. 1 2 final SClientboundDisconnectPacket packet = new SClientboundDisconnectPacket ( Component . text ( \"You were kicked, because why not.\" )); packet . sendPacket ( player ); And it is very recommended to use the fluent accessors. 1 2 3 new SClientboundDisconnectPacket () . reason ( Component . text ( \"You were kicked, because why not.\" )) . sendPacket ( player );","title":"Packets"},{"location":"modules/packets/#packets","text":"Module for accessing Minecraft's packets.","title":"Packets"},{"location":"modules/packets/#features","text":"Sending packets Listening to packets","title":"Features"},{"location":"modules/packets/#usage","text":"Supported platforms are: bukkit Packet availability Not all packets are currently mapped! Most serverbound packets are currently not available.","title":"Usage"},{"location":"modules/packets/#maven","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> packets-YOUR_PLATFORM </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package -->","title":"Maven"},{"location":"modules/packets/#gradle","text":"1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:packets-YOUR_PLATFORM:2.0.1-SNAPSHOT' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:2.0.1-SNAPSHOT' }","title":"Gradle"},{"location":"modules/packets/#examples","text":"","title":"Examples"},{"location":"modules/packets/#sending-a-packet","text":"I will demonstrate the functionality on the ClientboundDisconnectPacket. First of all, construct the SLib packet with it's constructor. 1 final SClientboundDisconnectPacket packet = new SClientboundDisconnectPacket (); Then, add the data to the packet. 1 2 final SClientboundDisconnectPacket packet = new SClientboundDisconnectPacket (); packet . reason ( Component . text ( \"You were kicked, because why not.\" )); And lastly, send the packet. 1 2 3 final SClientboundDisconnectPacket packet = new SClientboundDisconnectPacket (); packet . reason ( Component . text ( \"You were kicked, because why not.\" )); packet . sendPacket ( player ); It is also possible to directly supply the data in the constructor. 1 2 final SClientboundDisconnectPacket packet = new SClientboundDisconnectPacket ( Component . text ( \"You were kicked, because why not.\" )); packet . sendPacket ( player ); And it is very recommended to use the fluent accessors. 1 2 3 new SClientboundDisconnectPacket () . reason ( Component . text ( \"You were kicked, because why not.\" )) . sendPacket ( player );","title":"Sending a packet"},{"location":"modules/plugin/","text":"Plugin \u00b6 Module required for generating platform plugin classes. Features \u00b6 List of all plugins Main class generation Plugin file (like plugin.yml) generation Usage \u00b6 Supported platforms are: bukkit, sponge, minestom, bungee, velocity Maven \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> plugin-YOUR_PLATFORM </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package --> Gradle \u00b6 1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:plugin-YOUR_PLATFORM:2.0.1-SNAPSHOT' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:2.0.1-SNAPSHOT' } Examples \u00b6 Making your first plugin \u00b6 Adventure If you're experiencing errors related to Adventure , make sure to relocate the net.kyori.adventure package! Creating the main plugin class \u00b6 Start with extending the PluginContainer class, like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class ExamplePlugin extends PluginContainer { @Override public void load () { // Plugin load logic } @Override public void enable () { // Plugin enable logic } @Override public void disable () { // Plugin disable logic } } After that, add the @Plugin and @Init (only if you use SLib services) annotations. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Plugin ( id = \"ExamplePlugin\" , name = \"ExamplePlugin\" , authors = { \"ScreamingSandals\" }, version = \"0.0.1-SNAPSHOT\" ) @Init ( services = { ExampleService . class }) public class ExamplePlugin extends PluginContainer { @Override public void load () { // Plugin load logic } @Override public void enable () { // Plugin enable logic } @Override public void disable () { // Plugin disable logic } } If you want to depend on some plugin(s), you can add the @PluginDependencies annotation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Plugin ( id = \"ExamplePlugin\" , name = \"ExamplePlugin\" , authors = { \"ScreamingSandals\" }, version = \"0.0.1-SNAPSHOT\" ) @PluginDependencies ( platform = PlatformType . BUKKIT , dependencies = { \"DependencyPlugin\" }, softDependencies = { \"SoftDependencyPlugin\" }, loadBefore = { \"LoadBeforePlugin\" }) @Init ( services = { ExampleService . class }) public class ExamplePlugin extends PluginContainer { @Override public void load () { // Plugin load logic } @Override public void enable () { // Plugin enable logic } @Override public void disable () { // Plugin disable logic } } And that's it! Interacting with other plugins \u00b6 There's the PluginManager class for that, let me show you an example. For all next steps, you will need the plugin key, which you can get with the PluginKey PluginManager#createKey(String) method, like this: 1 2 // takes the plugin name final PluginKey key = PluginManager . createKey ( \"ExamplePlugin\" ); Checking if a plugin is enabled \u00b6 For checking if a plugin is enabled, you can use the boolean PluginManager#isEnabled(PluginKey) method. 1 2 3 4 5 if ( PluginManager . isEnabled ( key )) { PlayerMapper . getConsoleSender (). sendMessage ( \"Plugin is enabled!\" ); } else { PlayerMapper . getConsoleSender (). sendMessage ( \"Plugin is not enabled!\" ); } Getting the plugin's main class \u00b6 For getting the plugin's main class, you can use the @Nullable Object PluginManager#getPlatformClass(PluginKey) method. 1 final ExamplePlugin plugin = ( ExamplePlugin ) PluginManager . getPlatformClass ( key ); Getting all plugins on the server \u00b6 For getting all plugins on the server, you can use the List<PluginDescription> PluginManager#getAllPlugins() method. 1 2 3 for ( final PluginDescription plugin : PluginManager . getAllPlugins ()) { PlayerMapper . getConsoleSender (). sendMessage ( plugin . getName ()); }","title":"Plugin"},{"location":"modules/plugin/#plugin","text":"Module required for generating platform plugin classes.","title":"Plugin"},{"location":"modules/plugin/#features","text":"List of all plugins Main class generation Plugin file (like plugin.yml) generation","title":"Features"},{"location":"modules/plugin/#usage","text":"Supported platforms are: bukkit, sponge, minestom, bungee, velocity","title":"Usage"},{"location":"modules/plugin/#maven","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> plugin-YOUR_PLATFORM </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package -->","title":"Maven"},{"location":"modules/plugin/#gradle","text":"1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:plugin-YOUR_PLATFORM:2.0.1-SNAPSHOT' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:2.0.1-SNAPSHOT' }","title":"Gradle"},{"location":"modules/plugin/#examples","text":"","title":"Examples"},{"location":"modules/plugin/#making-your-first-plugin","text":"Adventure If you're experiencing errors related to Adventure , make sure to relocate the net.kyori.adventure package!","title":"Making your first plugin"},{"location":"modules/plugin/#creating-the-main-plugin-class","text":"Start with extending the PluginContainer class, like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class ExamplePlugin extends PluginContainer { @Override public void load () { // Plugin load logic } @Override public void enable () { // Plugin enable logic } @Override public void disable () { // Plugin disable logic } } After that, add the @Plugin and @Init (only if you use SLib services) annotations. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Plugin ( id = \"ExamplePlugin\" , name = \"ExamplePlugin\" , authors = { \"ScreamingSandals\" }, version = \"0.0.1-SNAPSHOT\" ) @Init ( services = { ExampleService . class }) public class ExamplePlugin extends PluginContainer { @Override public void load () { // Plugin load logic } @Override public void enable () { // Plugin enable logic } @Override public void disable () { // Plugin disable logic } } If you want to depend on some plugin(s), you can add the @PluginDependencies annotation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Plugin ( id = \"ExamplePlugin\" , name = \"ExamplePlugin\" , authors = { \"ScreamingSandals\" }, version = \"0.0.1-SNAPSHOT\" ) @PluginDependencies ( platform = PlatformType . BUKKIT , dependencies = { \"DependencyPlugin\" }, softDependencies = { \"SoftDependencyPlugin\" }, loadBefore = { \"LoadBeforePlugin\" }) @Init ( services = { ExampleService . class }) public class ExamplePlugin extends PluginContainer { @Override public void load () { // Plugin load logic } @Override public void enable () { // Plugin enable logic } @Override public void disable () { // Plugin disable logic } } And that's it!","title":"Creating the main plugin class"},{"location":"modules/plugin/#interacting-with-other-plugins","text":"There's the PluginManager class for that, let me show you an example. For all next steps, you will need the plugin key, which you can get with the PluginKey PluginManager#createKey(String) method, like this: 1 2 // takes the plugin name final PluginKey key = PluginManager . createKey ( \"ExamplePlugin\" );","title":"Interacting with other plugins"},{"location":"modules/plugin/#checking-if-a-plugin-is-enabled","text":"For checking if a plugin is enabled, you can use the boolean PluginManager#isEnabled(PluginKey) method. 1 2 3 4 5 if ( PluginManager . isEnabled ( key )) { PlayerMapper . getConsoleSender (). sendMessage ( \"Plugin is enabled!\" ); } else { PlayerMapper . getConsoleSender (). sendMessage ( \"Plugin is not enabled!\" ); }","title":"Checking if a plugin is enabled"},{"location":"modules/plugin/#getting-the-plugins-main-class","text":"For getting the plugin's main class, you can use the @Nullable Object PluginManager#getPlatformClass(PluginKey) method. 1 final ExamplePlugin plugin = ( ExamplePlugin ) PluginManager . getPlatformClass ( key );","title":"Getting the plugin's main class"},{"location":"modules/plugin/#getting-all-plugins-on-the-server","text":"For getting all plugins on the server, you can use the List<PluginDescription> PluginManager#getAllPlugins() method. 1 2 3 for ( final PluginDescription plugin : PluginManager . getAllPlugins ()) { PlayerMapper . getConsoleSender (). sendMessage ( plugin . getName ()); }","title":"Getting all plugins on the server"},{"location":"modules/tasker/","text":"Tasker \u00b6 A library required for creating synchronous and asynchronous tasks within the plugin. Managing tasks without Tasker If you want to manage tasks yourself (without the Tasker library), you can utilize the Server#runSynchronously(Runnable) method to run a task synchronously. Features \u00b6 Self-cancelling tasks Asynchronous tasks Usage \u00b6 Supported platforms are: bukkit, bungee, minestom, sponge, velocity Maven \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> tasker-YOUR_PLATFORM </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package --> Gradle \u00b6 1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:tasker-YOUR_PLATFORM:2.0.1-SNAPSHOT' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:2.0.1-SNAPSHOT' } Examples \u00b6 Running tasks \u00b6 Start with registering the Tasker service class in your plugin's @Init annotation. 1 2 3 @Init ( services = { Tasker . class }) Normal task \u00b6 So let's say, that we want to create a task to send a message to console every 30 seconds until the server stops/plugin disables. First of all, let's create a task builder, which takes in a Runnable . 1 Tasker . build (() -> PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" )); Then, let's add the repeat time period. 1 Tasker . build (() -> PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" )). repeat ( 30 , TaskerTime . SECONDS ); Now let's start the task. 1 Tasker . build (() -> PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" )). repeat ( 30 , TaskerTime . SECONDS ). start (); And you're done! Self-cancelling task \u00b6 Let's create a task which sends a message to the console 10 times and then stops. First of all, let's create a task builder, which takes in a Function<TaskBase, Runnable> . 1 2 3 4 5 6 7 8 9 final AtomicInteger count = new AtomicInteger ( 0 ); Tasker . build ( taskBase -> () -> { if ( count . get () >= 10 ) { taskBase . cancel (); return ; } PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" ); count . getAndIncrement (); }); Then, let's run the task right away. 1 2 3 4 5 6 7 8 9 final AtomicInteger count = new AtomicInteger ( 0 ); Tasker . build ( taskBase -> () -> { if ( count . get () >= 10 ) { taskBase . cancel (); return ; } PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" ); count . getAndIncrement (); }). afterOneTick (). start (); Congrats, you've just made a self-cancelling task!","title":"Tasker"},{"location":"modules/tasker/#tasker","text":"A library required for creating synchronous and asynchronous tasks within the plugin. Managing tasks without Tasker If you want to manage tasks yourself (without the Tasker library), you can utilize the Server#runSynchronously(Runnable) method to run a task synchronously.","title":"Tasker"},{"location":"modules/tasker/#features","text":"Self-cancelling tasks Asynchronous tasks","title":"Features"},{"location":"modules/tasker/#usage","text":"Supported platforms are: bukkit, bungee, minestom, sponge, velocity","title":"Usage"},{"location":"modules/tasker/#maven","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> tasker-YOUR_PLATFORM </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package -->","title":"Maven"},{"location":"modules/tasker/#gradle","text":"1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:tasker-YOUR_PLATFORM:2.0.1-SNAPSHOT' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:2.0.1-SNAPSHOT' }","title":"Gradle"},{"location":"modules/tasker/#examples","text":"","title":"Examples"},{"location":"modules/tasker/#running-tasks","text":"Start with registering the Tasker service class in your plugin's @Init annotation. 1 2 3 @Init ( services = { Tasker . class })","title":"Running tasks"},{"location":"modules/tasker/#normal-task","text":"So let's say, that we want to create a task to send a message to console every 30 seconds until the server stops/plugin disables. First of all, let's create a task builder, which takes in a Runnable . 1 Tasker . build (() -> PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" )); Then, let's add the repeat time period. 1 Tasker . build (() -> PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" )). repeat ( 30 , TaskerTime . SECONDS ); Now let's start the task. 1 Tasker . build (() -> PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" )). repeat ( 30 , TaskerTime . SECONDS ). start (); And you're done!","title":"Normal task"},{"location":"modules/tasker/#self-cancelling-task","text":"Let's create a task which sends a message to the console 10 times and then stops. First of all, let's create a task builder, which takes in a Function<TaskBase, Runnable> . 1 2 3 4 5 6 7 8 9 final AtomicInteger count = new AtomicInteger ( 0 ); Tasker . build ( taskBase -> () -> { if ( count . get () >= 10 ) { taskBase . cancel (); return ; } PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" ); count . getAndIncrement (); }); Then, let's run the task right away. 1 2 3 4 5 6 7 8 9 final AtomicInteger count = new AtomicInteger ( 0 ); Tasker . build ( taskBase -> () -> { if ( count . get () >= 10 ) { taskBase . cancel (); return ; } PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" ); count . getAndIncrement (); }). afterOneTick (). start (); Congrats, you've just made a self-cancelling task!","title":"Self-cancelling task"}]}